import Foundation
import GRDB
import GRDBSQLite
import StructuredQueriesCore
import StructuredQueriesSQLite

/// A cursor of a structured query.
///
/// Iterates over and decodes all of the rows of a structured query.
public class QueryCursor<Element>: DatabaseCursor {
  public var _isDone = false
  public let _statement: GRDB.Statement

  @usableFromInline
  var decoder: SQLiteQueryDecoder

  @usableFromInline
    init(db: GRDB.Database, query: QueryFragment) throws {
    (_statement, decoder) = try db.prepare(query: query)
  }

  deinit {
    sqlite3_reset(_statement.sqliteStatement)
  }

  public func _element(sqliteStatement _: SQLiteStatement) throws -> Element {
    fatalError("Abstract method should be overridden in subclass")
  }

  @usableFromInline
  struct DecodingError: Error, CustomStringConvertible {
    let columnIndex: Int
    let columnName: String
    let sql: String

    @usableFromInline
    init(columnIndex: Int, columnName: String, sql: String) {
      self.columnIndex = columnIndex
      self.columnName = columnName
      self.sql = sql
    }

    @usableFromInline
    var description: String {
      """
      Expected column \(columnIndex) (\(columnName.debugDescription)) to not be NULL: â€¦

      \(sql)
      """
    }
  }
}

@usableFromInline
final class QueryValueCursor<QueryValue: QueryRepresentable>: QueryCursor<QueryValue.QueryOutput> {
  public typealias Element = QueryValue.QueryOutput

  // NB: Required to workaround a "Legacy previews execution" bug
  //     https://github.com/pointfreeco/sharing-grdb/pull/60
  @usableFromInline
    override init(db: GRDB.Database, query: QueryFragment) throws {
    try super.init(db: db, query: query)
  }

  @inlinable
  public override func _element(sqliteStatement _: SQLiteStatement) throws -> Element {
    do {
      let element = try QueryValue(decoder: &decoder).queryOutput
      decoder.next()
      return element
    } catch QueryDecodingError.missingRequiredColumn {
      let columnIndex = Int(decoder.currentIndex) - 1
      throw DecodingError(
        columnIndex: columnIndex,
        columnName: _statement.columnNames[columnIndex],
        sql: _statement.sql
      )
    }
  }
}

@available(iOS 17, macOS 14, tvOS 17, watchOS 10, *)
@usableFromInline
final class QueryPackCursor<
  each QueryValue: QueryRepresentable
>: QueryCursor<(repeat (each QueryValue).QueryOutput)> {
  public typealias Element = (repeat (each QueryValue).QueryOutput)

  // NB: Required to workaround a "Legacy previews execution" bug
  //     https://github.com/pointfreeco/sharing-grdb/pull/60
  @usableFromInline
    override init(db: GRDB.Database, query: QueryFragment) throws {
    try super.init(db: db, query: query)
  }

  @inlinable
  public override func _element(sqliteStatement _: SQLiteStatement) throws -> Element {
    do {
      let element = try decoder.decodeColumns((repeat each QueryValue).self)
      decoder.next()
      return element
    } catch QueryDecodingError.missingRequiredColumn {
      let columnIndex = Int(decoder.currentIndex) - 1
      throw DecodingError(
        columnIndex: columnIndex,
        columnName: _statement.columnNames[columnIndex],
        sql: _statement.sql
      )
    }
  }
}

@usableFromInline
final class QueryVoidCursor: QueryCursor<Void> {
  typealias Element = ()

  // NB: Required to workaround a "Legacy previews execution" bug
  //     https://github.com/pointfreeco/sharing-grdb/pull/60
  @usableFromInline
    override init(db: GRDB.Database, query: QueryFragment) throws {
    try super.init(db: db, query: query)
  }

  @inlinable
  override func _element(sqliteStatement _: SQLiteStatement) throws {
    try decoder.decodeColumns(Void.self)
    decoder.next()
  }
}

extension GRDB.Database {
  @inlinable
  func prepare(query: QueryFragment) throws -> (GRDB.Statement, SQLiteQueryDecoder) {
    var (sql, bindings) = query.prepare { _ in "?" }
    if sql.isEmpty {
      sql = "SELECT 1 WHERE 0 -- Empty query generated by StructuredQueries"
    }
    let statement = try makeStatement(sql: sql)
    statement.arguments = try StatementArguments(bindings.map { try $0.databaseValue })
    return (
      statement,
      SQLiteQueryDecoder(statement: statement.sqliteStatement)
    )
  }
}

extension QueryBinding {
  @inlinable
  var databaseValue: DatabaseValue {
    get throws {
      switch self {
      case let blob as BlobBinding:
        return Data(blob.value).databaseValue
      case let bool as BoolBinding:
        // SQLite stores booleans as integers
        return (bool.value ? 1 : 0).databaseValue
      case let date as DateBinding:
        return date.value.iso8601String.databaseValue
      case let double as DoubleBinding:
        return double.value.databaseValue
      case let int as IntBinding:
        return int.value.databaseValue
      case is NullBinding:
        return .null
      case let text as TextBinding:
        return text.value.databaseValue
      case let uuid as UUIDBinding:
        return uuid.value.uuidString.lowercased().databaseValue
      case let uint64 as UInt64Binding:
        if let int64Value = uint64.int64Value {
          return int64Value.databaseValue
        } else {
          throw OverflowError()
        }
      case let invalid as InvalidBinding:
        throw invalid.error
      case let conditional as ConditionalQueryBinding<TextBinding, InvalidBinding>:
        // Handle ConditionalQueryBinding by recursively processing
        return try conditional.underlyingBinding.databaseValue
      default:
        // Check if it's an OptionalBinding
        let typeName = String(describing: type(of: self))
        if typeName.contains("OptionalBinding") {
          let mirror = Mirror(reflecting: self)
          if let wrappedValue = mirror.children.first(where: { $0.label == "wrapped" })?.value,
             let wrappedBinding = wrappedValue as? (any QueryBinding)? {
            if let unwrapped = wrappedBinding {
              return try unwrapped.databaseValue
            } else {
              return .null
            }
          }
        }
        // Handle unknown binding types - add type name for debugging
        throw InvalidBindingError(typeName: typeName)
      }
    }
  }
}

public struct InvalidBindingError: Error {
    public let typeName: String
    
    public init(typeName: String = "Unknown") {
        self.typeName = typeName
    }
}

public struct OverflowError: Error {
    public init() {}
}
