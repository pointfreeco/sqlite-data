# Fetching model data

Learn about the various tools for fetching data from a SQLite database.

## Overview

All data fetching happens by providing
[`fetchAll`](<doc:Sharing/SharedReaderKey/fetchAll(sql:arguments:database:)>),
[`fetchOne`](<doc:Sharing/SharedReaderKey/fetchOne(sql:arguments:database:)>), or
 [`fetch`](<doc:Sharing/SharedReaderKey/fetch(_:database:)-3qcpd>), to the `@SharedReader`
property wrapper. The primary differences between these choices is whether you want to specify your
query as a raw SQL string, or as a query built with GRDB's query building tools.

  * [Querying with SQL](#Querying-with-SQL)
  * [Querying with a SQL builder](#Querying-with-a-SQL-builder)
  * [Multiple queries in a single transaction](#Multiple-queries-in-a-single-transaction)

### Querying with SQL

For simple queries it can often be very convenient to specify how you want to fetch data from SQLite
as a raw SQL query string. For example, if you simply want to fetch all records from a table, you
can do so using the
[`fetchAll`](<doc:Sharing/SharedReaderKey/fetchAll(sql:arguments:database:)>) key:

```swift
@SharedReader(.fetchAll(sql: "SELECT * FROM items")) var items: [Item]
```

And if you want to sort the results, you can do so with an ordering clause:

```swift
@SharedReader(.fetchAll(sql: "SELECT * FROM items ORDER BY createdAt DESC"))
var items: [Item]
```

Or, if you want to only compute an aggregate of the data in a table, such as the count of the rows,
you can do so using the 
[`fetchOne`](<doc:Sharing/SharedReaderKey/fetchOne(sql:arguments:database:)>) key:

```swift
@SharedReader(.fetchOne(sql: "SELECT count(*) FROM items")) 
var itemsCount = 0
```

In each of these cases, the query is so simple that you may prefer writing the SQL yourself.
After all, the data is ultimately stored in SQLite, and so being very familiar with how SQL works is
only beneficial to you.

However, there are some downsides to this. First, complex queries can get very noisy at the call
site, such as if you have filtering logic:

```swift
@SharedReader(
  .fetchAll(
    sql: """
      SELECT * FROM items
      WHERE NOT isInStock
      ORDER BY createdAt DESC
      """
  )
)
var outOfStockItems: [Item]
```

And second, and most egregious, is that a raw string is susceptible to typos and the compiler cannot
help us write valid SQL code. For example, if we accidentally specified "`ORDER`" instead of
"`ORDER BY`":

```swift
@SharedReader(
  .fetchAll(
    sql: """
      SELECT * FROM items
      WHERE NOT isInStock
      ORDER createdAt DESC
      """
  )
)
var outOfStockItems: [Item]
```

â€¦then this will compile just fine but will be a runtime error. And further, you will often need to
build up a complex query from various settings in your feature, and doing so will rely on messy
string interpolation.

For these reasons, and more, people turn to query builders.

### Querying with a SQL builder

The GRDB library comes with a set of [query building tools][query-interface] that allow one to build
SQL statements in a safer manner. For example, something as simple as:

```swift
let query = Item.all()
```

â€¦represents the SQL statement:

```sql
SELECT * FROM items
```

And the following:

```swift
let query = Item.all()
  .filter(!Column("isInStock"))
  .order(Column("createdAt").desc)
```

â€¦represents the SQL statement:

```sql
SELECT * FROM items
WHERE NOT isInStock
ORDER BY createdAt DESC
```

Some may prefer writing their SQL statements in this style rather than a raw SQL string, but we
always recommend being fully familiar with the underlying SQL being generated by the builder.

Unfortunately, one cannot use this query builder directly with the `@SharedReader` like this:

```swift
@SharedReader(.fetch(Item.all())) var items  ðŸ›‘
```

This is because the query builder does not provide a unique, `Hashable` identity, which is necessary
to be used with `@SharedReader`. To work around this, one simply defines a conformance to our
``FetchKeyRequest`` protocol, which requires hashability, and in that conformance one can use
the builder tools to query the database:

```swift
struct Items: FetchKeyRequest {
  func fetch(_ db: Database) throws -> [Item] {
    try Item.all()
      .filter(!Column("isInStock"))
      .order(Column("createdAt").desc)
      .fetch(db)
  }
}
```
 
With this conformance defined one can use 
[`fetch`](<doc:Sharing/SharedReaderKey/fetch(_:database:)-3qcpd>) key to execute the
query specified by the `Items` type:

```swift
@SharedReader(.fetch(Items()) var items
```

> Note: Because of the type information available to `Items`, the type and default value can be
> omitted from the declaration of `items`.

Typically the conformances to ``FetchKeyRequest`` can even be made private and nested inside
whatever type they are used in, such as SwiftUI view, `@Observable` model, or UIKit view controller.
The only time it needs to be made public is if it's shared amongst many features.

### Multiple queries in a single transaction

Querying with ``FetchKeyRequest`` has the added benefit of being able to execute multiple queries in
a single database transaction. Right now each instance of `@SharedReader` in a feature executes
each of their queries in a separate transaction. So, if we wanted to query for all in stock
items, as well as the count of all items (in stock plus out of stock) like so:

```swift
@SharedReader(.fetchOne(sql: "SELECT count(*) FROM items"))
var itemsCount = 0

@SharedReader(.fetchAll(sql: "SELECT * FROM items WHERE isInStock"))
var inStockItems: [Item]
```

â€¦this is technically 2 queries run in 2 separate database transactions.

Often this can be just fine, but if you have multiple queries that tend to change at the same
time (_e.g._, when items are created or deleted, `itemsCount` and `inStockItems` will change
at the same time), then you can use ``FetchKeyRequest`` to bundle these two queries into a single
transaction.

To do this, define a ``FetchKeyRequest/Value`` type inside the conformance that represents all the
data you want to query for, and then construct it inside the ``FetchKeyRequest/fetch(_:)``
method:

```swift
struct Items: FetchKeyRequest {
  struct Value {
    var inStockItems: [Item] = []
    var itemsCount = 0
  }
  func fetch(_ db: Database) throws -> Value {
    try Value(
      inStockItems: Item.all().filter(Column("isInStock")).fetchAll(db),
      itemsCount: Item.fetchCount(db)
    )
  }
}
```

This selects the in-stock items and the total count of items as two queries inside a single database
transaction.

Then you can use this key just as you did before, but now you can access the `inStockItems` and
`itemsCount` properties to access the queried data:

```swift
@SharedReader(.fetch(Items())) var items = Items.Value()
items.inStockItems  // [Item(/* ... */), /* ... */]
items.itemsCount    // 100
```

> Note: A default must be provided to `@SharedReader` since it is querying for a custom data type
> instead of a collection of data.

[query-interface]: https://swiftpackageindex.com/groue/grdb.swift/master/documentation/grdb/queryinterface
